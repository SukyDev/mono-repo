name: iOS CI

on:
  pull_request:
    branches: [ main, development ]
  push:
    branches: [ main, development ]
  workflow_dispatch:

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      cicdtesting: ${{ steps.filter.outputs.cicdtesting }}
      cicdtestingdev: ${{ steps.filter.outputs.cicdtestingdev }}
      commonpackage: ${{ steps.filter.outputs.commonpackage }}
      workflow-changed: ${{ steps.filter.outputs.workflow }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            cicdtesting:
              - 'Apps/CiCdTesting/**'
            cicdtestingdev:
              - 'Apps/CiCdTestingDev/**'
            commonpackage:
              - 'Packages/Sources/CommonPackage/**'
            workflow:
              - '.github/workflows/**'

  tests:
    needs: detect-changes
    if: needs.detect-changes.outputs.cicdtesting == 'true' || needs.detect-changes.outputs.cicdtestingdev == 'true' || needs.detect-changes.outputs.commonpackage == 'true' || needs.detect-changes.outputs.workflow-changed == 'true'
    runs-on: macos-latest
    strategy:
      matrix:
        include:
          - name: CiCdTesting
            folder: Apps/CiCdTesting/CiCdTesting/CiCdTesting
            project_file: CiCdTesting.xcodeproj
            scheme: CiCdTesting
            package_name: cicd-ios
            test_target: ContentViewTests
            snapshot_reference_dir: CiCdTesting/cicd-ios/Tests/XCTestSupport/ReferenceImages
          - name: CiCdTestingDev
            folder: Apps/CiCdTestingDev/CiCdTestingDev/CiCdTestingDev
            project_file: CiCdTestingDev.xcodeproj
            scheme: CiCdTestingDev
            package_name: cicddev-ios
            test_target: ContentViewTests
            snapshot_reference_dir: CiCdTestingDev/cicddev-ios/Tests/XCTestSupport/ReferenceImages
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
      - name: Checkout LFS objects
        run: |
          echo "Pulling LFS objects..."
          git lfs pull
          echo "LFS pull completed"

      - name: Verify LFS files
        run: |
          echo "Checking LFS status..."
          git lfs ls-files
          echo ""
          echo "Checking for reference images in repository..."
          find Apps -name "ReferenceImages" -type d 2>/dev/null || echo "No ReferenceImages directories found"
          echo ""
          echo "Checking for image files..."
          find Apps -path "*/ReferenceImages/*.png" -o -path "*/ReferenceImages/*.jpg" 2>/dev/null || echo "No image files found"

      - name: Check if project should run
        id: check
        run: |
          # Check if CommonPackage or workflow changed (run all projects)
          if [ "${{ needs.detect-changes.outputs.commonpackage }}" == "true" ] || [ "${{ needs.detect-changes.outputs.workflow-changed }}" == "true" ]; then
            echo "CommonPackage or workflow changed - running all projects"
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if this specific project changed
          if [ "${{ matrix.name }}" == "CiCdTesting" ] && [ "${{ needs.detect-changes.outputs.cicdtesting }}" == "true" ]; then
            echo "CiCdTesting changed - running tests"
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          if [ "${{ matrix.name }}" == "CiCdTestingDev" ] && [ "${{ needs.detect-changes.outputs.cicdtestingdev }}" == "true" ]; then
            echo "CiCdTestingDev changed - running tests"
            echo "skip=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Otherwise skip
          echo "Project ${{ matrix.name }} did not change - skipping"
          echo "skip=true" >> $GITHUB_OUTPUT

      - name: Select Xcode
        if: steps.check.outputs.skip != 'true'
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.4.0'
      - name: Setup Ruby
        if: steps.check.outputs.skip != 'true'
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true
          working-directory: ${{ matrix.folder }}
      - name: Install Fastlane dependencies
        if: steps.check.outputs.skip != 'true'
        run: |
          cd ${{ matrix.folder }}
          bundle install

      - name: Create and boot iPhone SE (3rd generation) simulator
        id: simulator
        if: steps.check.outputs.skip != 'true'
        run: |
          set -e

          RUNTIME_ID="com.apple.CoreSimulator.SimRuntime.iOS-18-6"

          # Verify runtime exists
          if ! xcrun simctl list runtimes | grep -q "iOS 18.6"; then
            echo "âŒ iOS 18.6 runtime not installed"
            xcrun simctl list runtimes
            exit 1
          fi

          echo "Using runtime: $RUNTIME_ID"

          # First check if we already have one
          EXISTING_DEVICE=$(xcrun simctl list devices available | grep "iPhone SE (3rd generation)" | grep "18.4" | head -1 | grep -o '[A-F0-9]\{8\}-[A-F0-9]\{4\}-[A-F0-9]\{4\}-[A-F0-9]\{4\}-[A-F0-9]\{12\}' || echo "")

          if [ -n "$EXISTING_DEVICE" ]; then
            echo "Found existing iPhone SE simulator: $EXISTING_DEVICE"
            DEVICE_ID="$EXISTING_DEVICE"
          else
            echo "Creating new iPhone SE simulator..."
            DEVICE_ID=$(xcrun simctl create \
              "iPhone SE (3rd generation)" \
              "iPhone SE (3rd generation)" \
              "$RUNTIME_ID")
          fi

          echo "DEVICE_ID=$DEVICE_ID" >> $GITHUB_OUTPUT
          echo "Using device: $DEVICE_ID"

          # Boot the device
          xcrun simctl boot "$DEVICE_ID" || echo "Device may already be booted"
          xcrun simctl bootstatus "$DEVICE_ID" -b

          # Verify the device
          echo ""
          echo "Verifying simulator is ready..."
          xcrun simctl list devices | grep "$DEVICE_ID"

      - name: Verify Reference Images Exist
        if: steps.check.outputs.skip != 'true'
        run: |
          cd ${{ matrix.folder }}
          REFERENCE_DIR="${{ matrix.snapshot_reference_dir }}"

          echo "Checking for reference images directory: $REFERENCE_DIR"

          if [ ! -d "$REFERENCE_DIR" ]; then
            echo "âŒ Reference images directory not found at: $REFERENCE_DIR"
            echo "Please ensure reference images are committed to the repository via Git LFS"
            exit 1
          fi

          # Count existing reference images
          IMAGE_COUNT=$(find "$REFERENCE_DIR" -type f \( -name "*.png" -o -name "*.jpg" \) 2>/dev/null | wc -l | tr -d ' ')

          if [ "$IMAGE_COUNT" -eq 0 ]; then
            echo "âš ï¸  No reference images found in $REFERENCE_DIR"
            echo "Please commit reference images before running snapshot tests"
            exit 1
          fi

          echo "âœ… Found $IMAGE_COUNT reference images"
          ls -la "$REFERENCE_DIR"

      - name: Approve Swift Macros for CLI build
        run: |
          echo "=== Approving Swift Macros ==="
          defaults write com.apple.dt.Xcode IDESkipMacroFingerprintValidation -bool YES
          echo "Macro validation disabled for this build"

      - name: Run Tests with Fastlane
        if: steps.check.outputs.skip != 'true'
        env:
          FB_REFERENCE_IMAGE_DIR: ${{ matrix.snapshot_reference_dir }}
          IMAGE_DIFF_DIR: FailureDiffs
          DEVICE_ID: ${{ steps.simulator.outputs.DEVICE_ID }}
        run: |
          cd ${{ matrix.folder }}
          echo "Using simulator ID: $DEVICE_ID"
          echo "Current directory: $(pwd)"
          echo "Directory contents:"
          ls -la
          bundle exec fastlane test || echo "Tests failed, but continuing to check output..."
          echo ""
          echo "Checking for test output:"
          if [ -d "test_output" ]; then
            echo "test_output directory exists:"
            ls -la test_output/
          else
            echo "âŒ test_output directory does not exist"
          fi

      - name: Generate Coverage Report with xcov
        if: steps.check.outputs.skip != 'true'
        id: coverage
        # REMOVED: continue-on-error: true
        # This will now fail the job if coverage is below threshold
        run: |
          cd ${{ matrix.folder }}

          # Check if test results exist before running coverage
          if [ ! -d "test_output" ] || [ ! -d "test_output/${{ matrix.scheme }}.xcresult" ]; then
            echo "âš ï¸  Test results not found, skipping coverage report"
            echo "coverage=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          bundle exec fastlane coverage minimum_coverage:10.0

      - name: Upload Coverage Report
        if: steps.check.outputs.skip != 'true' && always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-${{ matrix.name }}
          path: |
            ${{ matrix.folder }}/coverage_report/
            ${{ matrix.folder }}/test_output/
          retention-days: 30
      - name: Comment Coverage on PR
        if: github.event_name == 'pull_request' && steps.check.outputs.skip != 'true' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const coverage = '${{ steps.coverage.outputs.coverage }}' || '0';
            const threshold = 20.0;
            const passed = parseFloat(coverage) >= threshold;

            let comment = `## ðŸ“Š Code Coverage Report - ${{ matrix.name }}\n\n`;
            comment += `**Coverage:** ${coverage}% ${passed ? 'âœ…' : 'âŒ'}\n`;
            comment += `**Threshold:** ${threshold}%\n\n`;

            if (passed) {
              comment += `Code coverage meets the required threshold. Great job! ðŸŽ‰`;
            } else {
              comment += `âš ï¸ Code coverage is below the required threshold.\n\n`;
              comment += `Please add more tests to increase coverage above ${threshold}%.`;
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

      - name: Upload Snapshot Test Failures
        if: failure() && steps.check.outputs.skip != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: snapshot-failures-${{ matrix.name }}
          path: |
            ${{ matrix.folder }}/FailureDiffs/
            ${{ matrix.folder }}/${{ matrix.snapshot_reference_dir }}/
          retention-days: 7
          if-no-files-found: ignore
      - name: Comment Snapshot Test Results on PR
        if: failure() && github.event_name == 'pull_request' && steps.check.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            let comment = `## ðŸ“¸ Snapshot Test Failures - ${{ matrix.name }}\n\n`;
            comment += `Snapshot tests failed for this PR. The UI has changed from the reference images.\n\n`;
            comment += `**Next Steps:**\n`;
            comment += `1. Download the \`snapshot-failures-${{ matrix.name }}\` artifact from this workflow run\n`;
            comment += `2. Review the image differences in the \`FailureDiffs/\` folder\n`;
            comment += `3. If changes are intentional:\n`;
            comment += `   - Update reference images locally by running the tests\n`;
            comment += `   - Commit the updated reference images via Git LFS\n`;
            comment += `   - Push the changes\n`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  collect-tested:
    needs: [detect-changes, tests]
    if: success()
    runs-on: ubuntu-latest
    outputs:
      tested-projects: ${{ steps.collect.outputs.tested-projects }}
      has-projects: ${{ steps.collect.outputs.has-projects }}
    steps:
      - name: Debug outputs
        run: |
          echo "cicdtesting output: '${{ needs.detect-changes.outputs.cicdtesting }}'"
          echo "cicdtestingdev output: '${{ needs.detect-changes.outputs.cicdtestingdev }}'"
          echo "commonpackage output: '${{ needs.detect-changes.outputs.commonpackage }}'"
          echo "workflow-changed output: '${{ needs.detect-changes.outputs.workflow-changed }}'"

      - name: Collect tested projects
        id: collect
        run: |
          projects="[]"

          echo "Initial projects: $projects"

          # If CommonPackage or workflow changed, add all projects
          if [ "${{ needs.detect-changes.outputs.commonpackage }}" == "true" ] || [ "${{ needs.detect-changes.outputs.workflow-changed }}" == "true" ]; then
            echo "CommonPackage or workflow changed, adding all projects"
            projects='[{"name":"CiCdTesting","folder":"Apps/CiCdTesting/CiCdTesting/CiCdTesting","project_file":"CiCdTesting.xcodeproj","scheme":"CiCdTesting","package_name":"cicd-ios"},{"name":"CiCdTestingDev","folder":"Apps/CiCdTestingDev/CiCdTestingDev/CiCdTestingDev","project_file":"CiCdTestingDev.xcodeproj","scheme":"CiCdTestingDev","package_name":"cicddev-ios"}]'
          else
            # Otherwise, only add projects that changed
            if [ "${{ needs.detect-changes.outputs.cicdtesting }}" == "true" ]; then
              echo "Adding CiCdTesting to projects"
              projects=$(echo "$projects" | jq -c '. += [{"name":"CiCdTesting","folder":"Apps/CiCdTesting/CiCdTesting/CiCdTesting","project_file":"CiCdTesting.xcodeproj","scheme":"CiCdTesting","package_name":"cicd-ios"}]')
              echo "Projects after adding CiCdTesting: $projects"
            fi

            if [ "${{ needs.detect-changes.outputs.cicdtestingdev }}" == "true" ]; then
              echo "Adding CiCdTestingDev to projects"
              projects=$(echo "$projects" | jq -c '. += [{"name":"CiCdTestingDev","folder":"Apps/CiCdTestingDev/CiCdTestingDev/CiCdTestingDev","project_file":"CiCdTestingDev.xcodeproj","scheme":"CiCdTestingDev","package_name":"cicddev-ios"}]')
              echo "Projects after adding CiCdTestingDev: $projects"
            fi
          fi

          echo "Final projects: $projects"
          echo "tested-projects=$projects" >> $GITHUB_OUTPUT

          project_count=$(echo "$projects" | jq 'length')
          echo "Project count: $project_count"

          if [ "$project_count" -gt 0 ]; then
            echo "has-projects=true" >> $GITHUB_OUTPUT
          else
            echo "has-projects=false" >> $GITHUB_OUTPUT
          fi

  deploy:
    needs: [tests, collect-tested]
    if: needs.collect-tested.outputs.has-projects == 'true' && needs.tests.result == 'success' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    strategy:
      matrix:
        project: ${{ fromJson(needs.collect-tested.outputs.tested-projects) }}
    runs-on: macos-latest
    steps:
      - name: Debug matrix project
        run: |
          echo "Full project object: ${{ toJson(matrix.project) }}"
          echo "Project name: ${{ matrix.project.name }}"
          echo "Project folder: ${{ matrix.project.folder }}"
          echo "Project file: ${{ matrix.project.project_file }}"
          echo "Project scheme: ${{ matrix.project.scheme }}"

      - uses: actions/checkout@v4
      - name: Select Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.4.0'
      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true
          working-directory: ${{ matrix.project.folder }}
      - name: Install Fastlane dependencies
        run: |
          cd ${{ matrix.project.folder }}
          bundle install

      - name: Show build SDK
        run: xcodebuild -showsdks
      - name: Compute uppercase name
        run: echo "NAME_UPPER=$(echo ${{ matrix.project.name }} | tr '[:lower:]' '[:upper:]')" >> $GITHUB_ENV
      - name: Set dynamic provisioning profile key
        run: echo "PP_KEY=PROVISIONING_PROFILE_${NAME_UPPER}" >> $GITHUB_ENV
      - name: Install the Apple certificate and provisioning profile
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          BUILD_PROVISION_PROFILE_BASE64: ${{ secrets[env.PP_KEY] }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          PP_PATH=$RUNNER_TEMP/build_pp_${{ matrix.project.name }}.mobileprovision
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          echo -n "$BUILD_PROVISION_PROFILE_BASE64" | base64 --decode -o $PP_PATH

          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles

          PROFILE_UUID=$(
            security cms -D -i "$PP_PATH" \
              | plutil -extract UUID raw -
          )

          cp "$PP_PATH" ~/Library/MobileDevice/Provisioning\ Profiles/$PROFILE_UUID.mobileprovision

      - name: Approve Swift Macros for CLI build
        run: |
          echo "=== Approving Swift Macros ==="
          defaults write com.apple.dt.Xcode IDESkipMacroFingerprintValidation -bool YES
          echo "Macro validation disabled for this build"

      - name: Build and Archive with Fastlane
        run: |
          cd ${{ matrix.project.folder }}
          bundle exec fastlane build

      - name: Decode App Store Connect private key file
        env:
          API_KEY_BASE64: ${{ secrets.API_KEY_BASE64 }}
          API_KEY: ${{ secrets.KEY_ID }}
        run: |
          mkdir -p ~/private_keys
          echo -n "$API_KEY_BASE64" | base64 --decode -o ~/private_keys/AuthKey_$API_KEY.p8

      - name: Upload to TestFlight with Fastlane
        env:
          ISSUER_ID: ${{ secrets.ISSUER_ID }}
          API_KEY: ${{ secrets.KEY_ID }}
        run: |
          cd ${{ matrix.project.folder }}
          bundle exec fastlane deploy_testflight

      - name: Clean up keychain and provisioning profile
        if: ${{ always() }}
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db
          rm -f ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision
