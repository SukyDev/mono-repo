# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

# Apps/CiCdTestingDev/CiCdTestingDev/CiCdTestingDev/fastlane/Fastfile

default_platform(:ios)

platform :ios do
  before_all do
    setup_ci if ENV['CI']
  end

  desc "Run tests with code coverage"
  lane :test do |options|
    # Get device ID from environment (should be set by CI)
    device_id = ENV['DEVICE_ID']
    
    if device_id && !device_id.empty?
      destination = "platform=iOS Simulator,id=#{device_id}"
      UI.important "ğŸ¯ Using specific device ID: #{device_id}"
    else
      # Fallback: find ANY available iPhone SE (any iOS version)
      UI.important "âš ï¸  No DEVICE_ID provided, searching for any iPhone SE..."
      
      # List available simulators
      simulators = `xcrun simctl list devices available`.lines
      
      # Try to find iPhone SE with iOS 18.6 first
      iphone_se = simulators.find { |line| line.include?("iPhone SE (3rd generation)") && line.include?("18.6") }
      
      # If not found, try any iPhone SE with iOS 18
      if !iphone_se
        iphone_se = simulators.find { |line| line.include?("iPhone SE (3rd generation)") && line.include?("(18.") }
      end
      
      # If still not found, try any iPhone SE
      if !iphone_se
        iphone_se = simulators.find { |line| line.include?("iPhone SE (3rd generation)") }
      end
      
      if iphone_se
        # Extract UUID from the line
        device_id = iphone_se[/([A-F0-9-]{36})/, 1]
        destination = "platform=iOS Simulator,id=#{device_id}"
        UI.success "Found iPhone SE: #{iphone_se.strip}"
        UI.success "Using device ID: #{device_id}"
      else
        # Last resort: use by name and let xcodebuild pick one
        destination = "platform=iOS Simulator,name=iPhone SE (3rd generation)"
        UI.warning "No specific iPhone SE found, using name-based destination"
      end
    end
    
    # Project root is one level up from fastlane directory
    project_root = File.expand_path("..", __dir__)
    test_output_path = File.join(project_root, "test_output")
    # Use absolute path for derived data - critical for xcov to find coverage files
    derived_data_absolute = File.join(project_root, "DerivedData")
    
    UI.important "ğŸ“± Final destination: #{destination}"
    UI.important "ğŸ“‚ Fastlane directory: #{__dir__}"
    UI.important "ğŸ“‚ Project root: #{project_root}"
    UI.important "ğŸ“‚ Derived data: #{derived_data_absolute}"
    UI.important "ğŸ“‚ Output will be in: #{test_output_path}"
    
    begin
      scan(
        project: "CiCdTestingDev.xcodeproj",
        scheme: "CiCdTestingDev",
        testplan: "CiCdTestingDev",
        destination: destination,
        only_testing: ["ContentViewTests"],
        code_coverage: true,
        result_bundle: true,
        output_directory: test_output_path,
        buildlog_path: test_output_path,
        clean: true,
        parallel_testing: false,
        derived_data_path: derived_data_absolute,
        skip_build: false,
        reset_simulator: false
      )
      
      # After scan completes, check if output was created
      UI.success "âœ… Tests completed!"
      UI.important "Checking for output at: #{test_output_path}"
      
      if Dir.exist?(test_output_path)
        UI.success "âœ… test_output directory exists!"
        UI.important "Contents: #{Dir.entries(test_output_path).join(', ')}"
      else
        UI.error "âŒ test_output directory was NOT created at #{test_output_path}"
      end
      
    rescue => ex
      UI.error "Tests failed: #{ex.message}"
      UI.important "Checking if test results were still generated..."
      result_path = File.join(test_output_path, "CiCdTestingDev.xcresult")
      if File.exist?(result_path)
        UI.success "âœ… Test results exist at #{result_path}"
      else
        UI.error "âŒ No test results found at #{result_path}"
      end
      raise ex
    end
  end

  desc "Generate code coverage report with xcov"
lane :coverage do |options|
  minimum_coverage = options[:minimum_coverage] || 20.0
  
  # Project root is one level up from fastlane directory
  project_root = File.expand_path("..", __dir__)
  result_bundle_path = File.join(project_root, "test_output", "CiCdTestingDev.xcresult")
  coverage_output_path = File.join(project_root, "coverage_report")
  derived_data_absolute = File.join(project_root, "DerivedData")
  
  UI.important "ğŸ“‚ Looking for test results at: #{result_bundle_path}"
  UI.important "ğŸ“‚ Project root: #{project_root}"
  UI.important "ğŸ“‚ Derived data path: #{derived_data_absolute}"
  
  unless File.exist?(result_bundle_path)
    # Debug: show what actually exists
    test_output_dir = File.join(project_root, "test_output")
    if Dir.exist?(test_output_dir)
      UI.warning "test_output directory exists but .xcresult not found"
      UI.important "Contents: #{Dir.entries(test_output_dir).join(', ')}"
    else
      UI.warning "test_output directory doesn't exist at: #{test_output_dir}"
    end
    
    UI.user_error! "âŒ Test results not found at #{result_bundle_path}. Did you run tests first?"
  end
  
  UI.important "ğŸ“Š Generating coverage report from: #{result_bundle_path}"
  UI.important "ğŸ“Š Coverage output will be in: #{coverage_output_path}"
  
  xcov(
    scheme: "CiCdTestingDev",
    project: "CiCdTestingDev.xcodeproj",
    xccovreport_path: result_bundle_path,  # ğŸ”¥ ADD THIS LINE - point directly to .xcresult
    output_directory: coverage_output_path,
    json_report: true,
    html_report: true,
    markdown_report: true,
    minimum_coverage_percentage: minimum_coverage,
    include_test_targets: false,
    # derived_data_path: derived_data_absolute,  # ğŸ”¥ REMOVE OR COMMENT THIS - not needed with xccovreport_path
    ignore_file_path: File.join(project_root, ".xcovignore"),
    exclude_targets: "ComposableArchitecture.framework,Dependencies.framework,CombineSchedulers.framework,CustomDump.framework,IdentifiedCollections.framework,OrderedCollections.framework,XCTestDynamicOverlay.framework"
  )
  
  # Read the coverage percentage from xcov's output
  coverage_file = File.join(coverage_output_path, "index.json")
  if File.exist?(coverage_file)
    require 'json'
    data = JSON.parse(File.read(coverage_file))
    coverage = data['coverage']
    
    UI.success "ğŸ“Š Code Coverage: #{coverage}%"
    
    if coverage < minimum_coverage
      UI.user_error! "âŒ Code coverage (#{coverage}%) is below threshold (#{minimum_coverage}%)"
    else
      UI.success "âœ… Code coverage meets threshold!"
    end
    
    # Export for GitHub Actions
    if ENV['GITHUB_OUTPUT']
      File.open(ENV['GITHUB_OUTPUT'], 'a') do |f|
        f.puts "coverage=#{coverage}"
      end
    end
  else
    UI.warning "âš ï¸  Could not find coverage JSON file at #{coverage_file}"
  end
end

  desc "Run tests and generate coverage report"
  lane :test_with_coverage do |options|
    test(options)
    coverage(options)
  end

  desc "Build app for release"
  lane :build do
    clear_derived_data
    
    gym(
      project: "CiCdTestingDev.xcodeproj",
      scheme: "CiCdTestingDev",
      export_method: "app-store",
      export_options: "exportOptions.plist",
      output_directory: "build",
      output_name: "CiCdTestingDev.ipa",
      clean: true,
      derived_data_path: "DerivedData",
      build_path: "build",
      archive_path: "build/CiCdTestingDev.xcarchive",
      skip_package_ipa: false,
      xcargs: "SKIP_INSTALL=NO BUILD_LIBRARY_FOR_DISTRIBUTION=YES OTHER_SWIFT_FLAGS=\"-enable-experimental-prebuilts\""
    )
  end

  desc "Upload to TestFlight"
  lane :deploy_testflight do
    api_key = app_store_connect_api_key(
      key_id: ENV['API_KEY'],
      issuer_id: ENV['ISSUER_ID'],
      key_filepath: "#{Dir.home}/private_keys/AuthKey_#{ENV['API_KEY']}.p8"
    )
    
    pilot(
      api_key: api_key,
      ipa: "build/CiCdTestingDev.ipa",
      skip_waiting_for_build_processing: true
    )
  end

  desc "Full release process: build and upload"
  lane :release do
    build
    deploy_testflight
  end
end