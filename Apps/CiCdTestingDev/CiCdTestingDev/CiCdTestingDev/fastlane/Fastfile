# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

# Apps/CiCdTestingDev/CiCdTestingDev/CiCdTestingDev/fastlane/Fastfile

default_platform(:ios)

platform :ios do
  before_all do
    setup_ci if ENV['CI']
  end

  desc "Run tests with code coverage"
  lane :test do |options|
    device_id = ENV['DEVICE_ID']
    
    if device_id && !device_id.empty?
      destination = "platform=iOS Simulator,id=#{device_id}"
      UI.important "ğŸ¯ Using specific device ID: #{device_id}"
    else
      UI.important "âš ï¸  No DEVICE_ID provided, searching for any iPhone SE..."
      
      simulators = `xcrun simctl list devices available`.lines
      
      iphone_se = simulators.find { |line| line.include?("iPhone SE (3rd generation)") && line.include?("18.6") }
      
      if !iphone_se
        iphone_se = simulators.find { |line| line.include?("iPhone SE (3rd generation)") && line.include?("(18.") }
      end
      
      if !iphone_se
        iphone_se = simulators.find { |line| line.include?("iPhone SE (3rd generation)") }
      end
      
      if iphone_se
        device_id = iphone_se[/([A-F0-9-]{36})/, 1]
        destination = "platform=iOS Simulator,id=#{device_id}"
        UI.success "Found iPhone SE: #{iphone_se.strip}"
        UI.success "Using device ID: #{device_id}"
      else
        destination = "platform=iOS Simulator,name=iPhone SE (3rd generation)"
        UI.important "âš ï¸  No specific iPhone SE found, using name-based destination"
      end
    end
    
    project_root = File.expand_path("..", __dir__)
    test_output_path = File.join(project_root, "test_output")
    derived_data_absolute = File.join(project_root, "DerivedData")
    
    UI.important "ğŸ“± Final destination: #{destination}"
    UI.important "ğŸ“‚ Fastlane directory: #{__dir__}"
    UI.important "ğŸ“‚ Project root: #{project_root}"
    UI.important "ğŸ“‚ Derived data: #{derived_data_absolute}"
    UI.important "ğŸ“‚ Output will be in: #{test_output_path}"
    
    begin
      scan(
        project: "CiCdTestingDev.xcodeproj",
        scheme: "CiCdTestingDev",
        testplan: "CiCdTestingDev",
        destination: destination,
        only_testing: ["ContentViewTests"],
        code_coverage: true,
        result_bundle: true,
        output_directory: test_output_path,
        buildlog_path: test_output_path,
        clean: true,
        parallel_testing: false,
        derived_data_path: derived_data_absolute,
        skip_build: false,
        reset_simulator: false
      )
      
      UI.success "âœ… Tests completed!"
      UI.important "Checking for output at: #{test_output_path}"
      
      if Dir.exist?(test_output_path)
        UI.success "âœ… test_output directory exists!"
        UI.important "Contents: #{Dir.entries(test_output_path).join(', ')}"
      else
        UI.error "âŒ test_output directory was NOT created at #{test_output_path}"
      end
      
    rescue => ex
      UI.error "Tests failed: #{ex.message}"
      UI.important "Checking if test results were still generated..."
      result_path = File.join(test_output_path, "CiCdTestingDev.xcresult")
      if File.exist?(result_path)
        UI.success "âœ… Test results exist at #{result_path}"
      else
        UI.error "âŒ No test results found at #{result_path}"
      end
      raise ex
    end
  end

  desc "Generate code coverage report with xcov"
  lane :coverage do |options|
    minimum_coverage = options[:minimum_coverage] || 20.0
    
    project_root = File.expand_path("..", __dir__)
    result_bundle_path = File.join(project_root, "test_output", "CiCdTestingDev.xcresult")
    coverage_output_path = File.join(project_root, "coverage_report")
    derived_data_absolute = File.join(project_root, "DerivedData")
    
    UI.important "ğŸ“‚ Looking for test results at: #{result_bundle_path}"
    UI.important "ğŸ“‚ Project root: #{project_root}"
    UI.important "ğŸ“‚ Derived data path: #{derived_data_absolute}"
    
    unless File.exist?(result_bundle_path)
      test_output_dir = File.join(project_root, "test_output")
      if Dir.exist?(test_output_dir)
        UI.important "âš ï¸  test_output directory exists but .xcresult not found"
        UI.important "Contents: #{Dir.entries(test_output_dir).join(', ')}"
      else
        UI.important "âš ï¸  test_output directory doesn't exist at: #{test_output_dir}"
      end
      
      UI.user_error! "âŒ Test results not found at #{result_bundle_path}. Did you run tests first?"
    end
    
    UI.important "ğŸ“Š Generating coverage report from: #{result_bundle_path}"
    UI.important "ğŸ“Š Coverage output will be in: #{coverage_output_path}"
    
    xcov(
      scheme: "CiCdTestingDev",
      project: "CiCdTestingDev.xcodeproj",
      xccov_file_direct_path: result_bundle_path,
      output_directory: coverage_output_path,
      json_report: true,
      html_report: true,
      markdown_report: true,
      minimum_coverage_percentage: minimum_coverage,
      include_test_targets: false,
      ignore_file_path: File.join(project_root, ".xcovignore"),
      exclude_targets: [
        "CiCdTestingDev.app",  # Exclude the main app target
        "CiCdTestingDevTests",  # Exclude test targets
        "CiCdTestingDevUITests",  # Exclude UI test targets
        "ComposableArchitecture.framework",
        "Dependencies.framework",
        "CombineSchedulers.framework",
        "CustomDump.framework",
        "IdentifiedCollections.framework",
        "OrderedCollections.framework",
        "XCTestDynamicOverlay.framework",
        "Perception.framework",
        "swift-perception",
        "swift-dependencies",
        "swift-identified-collections",
        "swift-case-paths",
        "swift-custom-dump",
        "combine-schedulers",
        "xctest-dynamic-overlay"
      ].join(',')
    )
    
    coverage_file = File.join(coverage_output_path, "index.json")
    if File.exist?(coverage_file)
      require 'json'
      data = JSON.parse(File.read(coverage_file))
      coverage = data['coverage']
      
      UI.success "ğŸ“Š Code Coverage: #{coverage}%"
      
      if coverage < minimum_coverage
        UI.user_error! "âŒ Code coverage (#{coverage}%) is below threshold (#{minimum_coverage}%)"
      else
        UI.success "âœ… Code coverage meets threshold!"
      end
      
      if ENV['GITHUB_OUTPUT']
        File.open(ENV['GITHUB_OUTPUT'], 'a') do |f|
          f.puts "coverage=#{coverage}"
        end
      end
    else
      UI.important "âš ï¸  Could not find coverage JSON file at #{coverage_file}"
    end
  end

  desc "Run tests and generate coverage report"
  lane :test_with_coverage do |options|
    test(options)
    coverage(options)
  end

  desc "Build app for release"
  lane :build do
    # Simply increment build number by 1
    increment_build_number(xcodeproj: "CiCdTestingDev.xcodeproj")
    
    # Get the new build number for logging
    build_number = get_build_number(xcodeproj: "CiCdTestingDev.xcodeproj")
    UI.success "âœ… Building with build number: #{build_number}"
    
    gym(
      project: "CiCdTestingDev.xcodeproj",
      scheme: "CiCdTestingDev",
      export_method: "app-store",
      export_options: "exportOptions.plist",
      output_directory: "build",
      output_name: "CiCdTestingDev.ipa"
    )
  end

  desc "Upload to TestFlight"
  lane :deploy_testflight do
    project_root = File.expand_path("..", __dir__)
    ipa_path = File.join(project_root, "build", "CiCdTestingDev.ipa")
    
    UI.important "ğŸ“¦ Looking for IPA at: #{ipa_path}"
    
    unless File.exist?(ipa_path)
      UI.user_error! "âŒ IPA not found at #{ipa_path}. Did you run build first?"
    end
    
    ipa_size = File.size(ipa_path)
    UI.important "ğŸ“¦ IPA size: #{ipa_size} bytes"
    
    if ipa_size < 1000
      UI.user_error! "âŒ IPA file seems invalid (too small: #{ipa_size} bytes)"
    end
    
    api_key_path = ENV['API_KEY_PATH'] || "#{Dir.home}/private_keys/AuthKey_#{ENV['API_KEY']}.p8"
    
    UI.important "ğŸ”‘ API Key path: #{api_key_path}"
    
    unless File.exist?(api_key_path)
      UI.user_error! "âŒ API Key not found at #{api_key_path}"
    end
    
    api_key = app_store_connect_api_key(
      key_id: ENV['API_KEY'],
      issuer_id: ENV['ISSUER_ID'],
      key_filepath: api_key_path,
      in_house: false
    )
    
    UI.success "âœ… Using App Store Connect API Key"
    
    sh(
      "xcrun",
      "altool",
      "--upload-app",
      "--type", "ios",
      "--file", ipa_path,
      "--apiKey", ENV['API_KEY'],
      "--apiIssuer", ENV['ISSUER_ID']
    )
  end

  desc "Full release process: build and upload"
  lane :release do
    build
    deploy_testflight
  end
end